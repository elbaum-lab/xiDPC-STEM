% Generate parallax different iDPC contrast (piDPC) from a processed 4DSTEM tiltseries, previously called DiDPC.
% Using virtual sector detectors within the bright field area (sect1-8 files) generated by Arinatomo_rings code.
% Depends on deshift.m function and MRCImage library.
% Written by Shahar Seifer, Elbaum lab, Weizmann Insititute of Science 2025
clear;
[filename,path] = uigetfile('*sect1*.mrc','Fetch sect1 MRC file generated by Arinatomo_rings code.');
Chosen_Filename_ch1=[path filename];

for channel=1:8
    Chosen_Filename=strrep(Chosen_Filename_ch1,'sect1',sprintf('sect%d',channel));
    if channel==1
        newFilename11=strrep(Chosen_Filename,'sect1','piDPC');
    end
    flgLoadVolume=1;  % If 1 - Load in the volume data (default: 1)
    showHeader=1; %  If 1 - Print out information as the header is loaded.
    mRCImage=MRCImage;%Insentiate MRCImage in mRCImage
    mRCImage = open(mRCImage, Chosen_Filename, flgLoadVolume, showHeader);
    tilt = double(getVolume(mRCImage, [], [], []));
    ntilts = length(tilt(1,1,:));%getNZ(mRCImage);
    nX = getNX(mRCImage);
    nY = getNY(mRCImage);
    sizeXangstrom=getCellX(mRCImage);
    sizeYangstrom=getCellY(mRCImage);
    
    if channel==1
        tilts_channels=double(zeros(nX,nY,ntilts,4));
    end
    sect2quad=[2 2 3 3 4 4 1 1];
    Quad_channel=sect2quad(channel);
    tilts_channels(:,:,:,Quad_channel)=tilts_channels(:,:,:,Quad_channel)+tilt;
end

vnx=1:nX;
vny=1:nY;
[Y, X] = meshgrid( (1:nY)-(1+nY)/2,(1:nX)-(1+nX)/2);
[y, x] = meshgrid( 1:nY,1:nX);
kyp=Y/(nY);
kxp=X/(nX); 
kpnorm2=kxp.^2+kyp.^2;
kpnorm2(kpnorm2==0)=1e-6;
kpnorm=sqrt(kxp.^2+kyp.^2);


n1=1;
n2=ntilts;
ntilts=n2-n1+1;
newtilt=double(zeros(nX,nY,ntilts));

for tiltno=n1:n2
    COMx=tiltCOMx(:,:,tiltno);
    COMy=tiltCOMy(:,:,tiltno);
    img1=tilts_channels(:,:,tiltno,1);
    img2=tilts_channels(:,:,tiltno,2);
    img3=tilts_channels(:,:,tiltno,3);
    img4=tilts_channels(:,:,tiltno,4);

    [corr_offset(1,:),corr_offset(2,:),corr_offset(3,:),corr_offset(4,:)]=deshift(img1,img2,img3,img4)
    
    shift_avg_pix=(-corr_offset(1,1)-corr_offset(1,2)-corr_offset(2,1)+corr_offset(2,2)+corr_offset(3,1)+corr_offset(3,2)+corr_offset(4,1)-corr_offset(4,2))/8;
    tryshift=shift_avg_pix;
    img1_deshift=imtranslate(img1,-corr_offset(1,:));
    img2_deshift=imtranslate(img2,-corr_offset(2,:));
    img3_deshift=imtranslate(img3,-corr_offset(3,:));
    img4_deshift=imtranslate(img4,-corr_offset(4,:));
    img_gradx_shifted=-(img1_deshift+img2_deshift-img3_deshift-img4_deshift);
    img_grady_shifted=-(img2_deshift-img1_deshift+img3_deshift-img4_deshift);
    %iDPC1=intgrad2(img_grady_shifted,img_gradx_shifted);
    iDPC1fft=(1/(1i*2*pi))*((kxp.*(ifftshift(fft2(fftshift(img_gradx_shifted))))+kyp.*(ifftshift(fft2(fftshift(img_grady_shifted)))).*(1-1*(abs(kpnorm2)<0.000000001))))./kpnorm2;
    iDPC1=real(ifftshift(ifft2(fftshift(iDPC1fft))));


    img1_deshift=imtranslate(img1,-corr_offset(1,:)+1*[1 -1]);
    img2_deshift=imtranslate(img2,-corr_offset(2,:)+1*[-1 -1]);
    img3_deshift=imtranslate(img3,-corr_offset(3,:)+1*[-1 1]);
    img4_deshift=imtranslate(img4,-corr_offset(4,:)+1*[1 1]);
    img_gradx_shifted=-(img1_deshift+img2_deshift-img3_deshift-img4_deshift);
    img_grady_shifted=-(img2_deshift-img1_deshift+img3_deshift-img4_deshift);
    %iDPC11=intgrad2(img_grady_shifted,img_gradx_shifted);
    iDPC11fft=(1/(1i*2*pi))*((kxp.*(ifftshift(fft2(fftshift(img_gradx_shifted))))+kyp.*(ifftshift(fft2(fftshift(img_grady_shifted)))).*(1-1*(abs(kpnorm2)<0.000000001))))./kpnorm2;
    iDPC11=real(ifftshift(ifft2(fftshift(iDPC11fft))));
    DiDPC1=iDPC11-iDPC1;
    DiDPC1_LP=imgaussfilt(DiDPC1,50);
    DiDPC1_BP=DiDPC1-DiDPC1_LP;%imgaussfilt(DiDPC1-DiDPC1_LP,1);
    iDPC11tilt(:,:,tiltno-n1+1)=DiDPC1_BP;

end

newmRCImage = MRCImage;%Instentiate MRCImage object
newmRCImage.filename=newFilename11;
newmRCImage = setVolume(newmRCImage, iDPC11tilt); %enter to newmRCImage, do statistics, and fill many details to the header
newmRCImage.header.cellDimensionX = sizeXangstrom;
newmRCImage.header.cellDimensionY = sizeYangstrom;
save(newmRCImage, newFilename11);
close(newmRCImage);


